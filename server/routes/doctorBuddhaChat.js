const express = require('express');
const { OpenAI } = require('openai');

const router = express.Router();

// Initialize OpenAI with API keys and project ID
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
  project: process.env.OPENAI_PROJECT_ID,
});

const assistantId = process.env.OPENAI_DoctorBuddha_ASSISTANT_ID;
const threadId = process.env.OPENAI_DoctorBuddha_THREAD_ID;

router.get('/doctorBuddhaChat', async (req, res) => {
  const message = req.query.message;

  console.log('Message received (GET):', message);

  if (!message || typeof message !== 'string' || message.trim() === '') {
    return res.status(400).json({ error: 'Invalid message content' });
  }

  try {
    // 1. Store the user's message in the thread
    const createdMessage = await openai.beta.threads.messages.create(threadId, {
      role: 'user',
      content: message,
    });

    console.log('User message stored in thread:', createdMessage);

    // 2. Start the "run" to get the assistant's response
    const run = await openai.beta.threads.runs.create(threadId, {
      assistant_id: assistantId,
      stream: true,  // Enable streaming
      temperature: 0.7,
      top_p: 1.0,
      max_prompt_tokens: 3000,
      max_completion_tokens: 10000,
      truncation_strategy: { type: 'auto' },
      tools: [{ type: 'file_search' }],
      response_format: 'auto',
      parallel_tool_calls: true,
    });

    // Set up response headers for SSE
    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    });

    let accumulatedText = '';  // Variable to accumulate chunks of text
    let responseStarted = false;

    // Stream the assistant's response back to the client
    for await (const event of run) {
      if (event.event === 'thread.message.delta') {
        const textDelta = event.data.delta.content[0].text.value;

        // Accumulate the text and check if we have enough for a chunk
        accumulatedText += textDelta + ' ';  // Add spaces between words

        // If we have accumulated enough text (e.g., a sentence), stream it
        if (accumulatedText.length > 100 || textDelta.endsWith('.') || textDelta.endsWith('?')) {
          res.write(`data: ${accumulatedText}\n\n`);
          accumulatedText = '';  // Reset the accumulator after sending a chunk
        }

        responseStarted = true;
      }

      if (event.event === 'thread.run.completed') {
        // Send any remaining text before ending the stream
        if (accumulatedText.trim().length > 0) {
          res.write(`data: ${accumulatedText}\n\n`);
        }
        res.end();  // End the stream when the assistant has finished
      }
    }

    if (!responseStarted) {
      console.error('No response generated by assistant');
      res.write('data: No response from assistant.\n\n');
      res.end();
    }

  } catch (error) {
    console.error('Error processing request:', error);
    if (!res.headersSent) {
      res.status(500).json({ error: 'Internal Server Error', details: error.message });
    }
  }
});

module.exports = router;